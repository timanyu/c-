

# 一. 编译链接运行原理

## 1.编译链接原理

1.预编译（gcc -E hello.c -o hello.i）
预编译阶段主要处理那些源代码文件中的以“#”开头的预编译指令，并生成.i文件，.i文件属于文本文件 。处理的主要包括：

删除#define并进行文本替换
#if #endif  #elseif
递归展开#include
删除注释
添加行号和文件标识
保留#pragma
2.编译（gcc -S hello.i -o hello.s）
编译阶段将高级语言转成汇编代码并生成.s文件，.s文件属于文本文件。要处理的主要包括：

词法分析。利用扫描器将原代码的字符序列分割成一系列记号（关键字、标识符、特殊符号等）并标记。将标识符放在符号表中，常量在文字表中。
语法分析。用语法分析器对记号进行语法分析并产生语法树（以表达式为节点的树），是无关上下文的。
语义分析。搞清楚表达式的意思，是干什么的。编译器可以做到的是静态语义，也就是在编译期可以确定的语义。语义分析之后，整个语法树的表达式都被标识了类型。




静态语义：通常包含声明和类型的匹配，类型的转换等。

动态语义：像比如0作为除数就是一个运行期的语义错误。

3.汇编（gcc -c hello.s -o hello.o）
汇编阶段主要是将编译阶段生成的汇编代码编程二进制的机器语言并生成.o文件，称为目标文件，.o文件属于二进制文件。主要做的就是翻译指令。在这一阶段有生成中间文件，中间文件经过代码生成器优化（比如选择合适的寻址方式、使用位移代替乘法运算、删除多余的指令等）后才生成目标文件。中间文件使得编译器分为前端和后端，前端负责产生与机器无关的中间代码，后端（包括代码生成器和目标代码优化器）将中间代码转换成目标机器代码。



4.链接
在前面，每个文件都是单独编译的，但是在编译链接之后，不论源文件多或少，最终都只会生成一个可执行文件。而链接阶段就是将一个或多个目标文件链接成一个可执行文件。C/C++模块之间通信的方式：函数调用和模块间的变量访问，而这两个方式都是需要知道函数或者变量的地址。链接主要就是将各个模块相互连接的部分处理好。链接有静态链接和动态链接。主要处理包括：

合并各个段和符号表。
符号解析
分配地址和空间
符号重定位
静态链接：静态链接是以目标文件为单位，如使用了静态库中的printf函数，将会把含有printf函数的整个目标文件一起链接进来，也会有很多不用的函数，而且只要修改了库函数就要重新编译链接。不仅会浪费空间，更新也会麻烦。

动态链接：动态链接就是把程序的模块相互划分开来，形成独立的文件，而不再静态的链接在一起，把链接这个过程推迟到了运行时再进行。动态链接解决了静态链接的浪费空间的缺点，但是速度比较慢。


## 2.虚拟地址空间分布

.bss区：未初始化或初值为0的全局变量和静态局部变量；

.data区：已初始化且初值非0的全局变量和静态局部变量；

栈区：局部变量、函数参数、返回地址等。为每个函数开辟一个栈帧，存放该函数的内容；

堆区：自己申请的空间在堆区（动态分配的内存）。

代码段：可执行代码、字符串字面值、只读变量。

## 3.说一下c++的内存管理

## 4.全局变量和局部变量的区别(生命周期、作用域、默认值、内存区域、链接属性)

生命周期：全局变量在整个程序运行期间存在，局部变量只在所在函数运行时存在；

作用域：全局变量作用在全局，局部变量作用在所在函数；

默认值：全局变量默认值为1，局部变量默认值是随机数；

内存区域：全局变量在.bss区，局部变量在.data区；

连接属性：

## 5.堆和栈的区别

首先，堆和栈是内存上的俩块不同的区域；栈区资源由系统自己调用和释放，系统会为每个函数分配一个栈帧空间，用于存储该函数内的信息；堆区资源由用户自己申请调用，自己释放，所以有越界的风险，还有内存泄漏等风险。

栈的内存分配释放速度快效率高，内存都是连续的；堆内存的分配释放相对于栈来说效率低一些，内存不一定连续，容易产生内存碎片，但是灵活性高。

栈是由高地址向低地址扩展的连续内存，栈的大小一般为 2M 或者 10M（大家的redhat 系统可以用 ulimit -s 命令来查看，是 10M）；堆是由低地址向高地址扩展的非连续内存，堆的大小影响的因素比较多，和系统虚拟内存的大小有关系。

## 6.编译链接过程，在什么平台上，动态库出错，怎么找



# 二. C/C++区别

## 1.new和malloc的区别

属性：new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。

参数：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

返回类型：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

 自定义类型：new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。

malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

重载：C++允许自定义operator new 和 operator delete 函数控制动态内存的分配。

内存区域:new做两件事：分配内存和调用类的构造函数，delete是：调用类的析构函数和释放内存。而malloc和free只是分配和释放内存。

new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。

## 2.函数重载（重定义），c++函数符号生成规则

函数重载不以返回类型区分，而是以函数参数类型，个数，const修饰。

c语言生成函数符号仅看函数名，故无重载，而c++生成函数符号时，与上述内容相关。

## 3.指针和引用的区别

1.指针的大小是只被机器位数影响，32位系统下为4字节，64位下为8字节，引用的大小与它所引用的对象的大小有关；

2.指针可以指向空，但引用不能为空；

3.指针可以有多级指针，引用只能一级；

4.指针可以改变指向，引用由于底层有const，无法改变引用对象；

## 4.内联函数的使用场景

内联函数用于函数结构不复杂的时候，有时即使你定义了内联函数，编译器也不会以内联的方式运行。

## 5.static 关键字 C++方面的用法

\1. 全局静态变量

在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.

静态存储区，在整个程序运行期间一直存在。

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

\2.  局部静态变量

在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。

内存中的位置：静态存储区

初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；

作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；

\3. 静态函数

在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。

函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；

\4. 类的静态成员

在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用

\5. 类的静态函数

静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。

在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

## 6.C++中的 const 是为了干什么

const修饰一个变量或者指针，表示其中的内容不可改变，为常性；

## 7.new 失败会怎样，不想抛出异常该怎么办

C++ 里，如果 new 分配内存失败，默认是**抛出异常**的。所以，如果分配成功，p == 0 就绝对不会成立；而如果分配失败了，也不会执行 if ( p == 0 )，因为分配失败时，new 就会**抛出异常跳过后面的代码**。如果你想检查 new 是否成功，应该**捕捉异常**：

​    ``try {`
​      `int* p = new int[SIZE];`
​      `// 其它代码`
​    `} catch ( const bad_alloc& e ) {`
​      `return -1;`
​    }`

  据说一些老的编译器里，new 如果分配内存失败，是不抛出异常的（大概是因为那时 C++ 还没加入异常机制），而是和 malloc 一样，返回空指针。不过我从来都没遇到过 new 返回空指针的情况。

  当然，标准 C++ 亦提供了一个方法来**抑制 new 抛出异常**，而返回空指针：

​    `[int* p = new (std::nothrow) int; // 这样如果 new 失败了，就不会抛出异常，而是返回空指针
​    if ( p == 0 ) // 如此这般，这个判断就有意义了
​      return -1;
​    // 其它代码]()`

## 8.delete 释放单个对象和数组的区别

1. delete 释放new分配的单个对象指针指向的内存；

1）对于简单类型，内存大小已确定，析构时系统可直接通过指针获取实际分配的内存空间并释放；

2）对于类对象数组，仅调用数组首对象的析构函数，剩下对象的空间不能被释放；

2. delete[] 释放new分配的对象数组指针指向的内存。

1）对于简单类型，效果同delete，可以释放数组内存空间；

2）对于类对象数组，将逐一调用数组中每个对象的析构函数，释放了指针指向的全部内存空间。

# 三．C++基础

## 1. 说说 OOP 思想，举个例子说明面向过程和面向对象的区别

面向对象编程：Object-oriented Programming，OOP，面向对象程序设计。

面向对象编程是一种**计算机编程架构**，他的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。

OOP使得程序更有重用性、灵活性和扩展性。OOP的核心思想是：**封装**、**继承**、**多态**（重点是**类**和**对象**）。

不同于POP（面向过程编程）的以过程为中心的编程思想，面向对象编程的中心思想是通过调用对象来实现想要实现的目的。

面向对象的思想：

1. 是一种更符合我们思想习惯的思想；
2. 可以将复杂的事情简单化；
3. 将我们从执行者变成了指挥者。

举例：

让一辆法拉利以200KM/h 路在一条10000KM的路,问需要多少时间？
		面向过程: 时间 = 路程 / 速度      数学思维
		面向对象: 有一个车(名字:法拉利,速度:200KM/h)   跑,
		         一要路(长度: 10000KM) 

		盖房子:  备料-打地基-砌墙-封顶-装修       亲力亲为的体验,
		盖房子:  工程队    装修公司              指挥者的体验
## 2.struct 和 class 区别

struct默认成员为私有成员，class默认为公有成员；

struct更适合看成是一个数据结构的实现体，class更适合看成是一个对象的实现体。

## 3.C++中的空类，你知道吗？对空类求 sizeof,结果怎样？哪些情况会对它有影响，static 变量对其有影响吗

## 4. private 和 protect 的区别

## 5. 什么是友元关系，为什么要有友元

## 6. STL 中的模板定义和声明为什么都写在同一个文件中

## 7. 函数指针，在哪用过（项目，C，vector 内存配置器） 

## 8. 如果析构函数里面抛出异常会怎么样

## 9. 如果构造函数里面抛出异常呢？会造成内存泄漏吗

## 10. 深拷贝 浅拷贝，写时拷贝的特点

## 11. 内存池讲一下

## 12. C++的组合说一下

## 13. 说下重载 隐藏 覆盖

## 14. 说一下继承 封装 多态

## 15. 私有继承是 is-a 还是 has-s 关系

## 16. C++中的四种类型转换

## 17. C++的动多态实现原理

## 18. 讲下虚函数，纯虚函数，纯虚函数有什么用

## 19. 什么函数不能声明为虚函数

## 20. 虚函数的实现原理

## 21. 虚函数表中存的都有什么内容

## 22. 说一下 RTTI

## 23. 虚析构有什么用

## 24. 析构函数一定要写成虚函数吗

## 25. 重载和重写的区别

## 26. 怎么实现一个不可继承的类
